CHAPTER 1: WHY HTTP

LESSON 1:
Communicating on the Web
Instagram would be pretty terrible if you had to manually copy your photos to your friend's phone when you wanted to share them. Modern applications need to be able to communicate information between devices over the internet.

Gmail doesn't just store your emails in variables on your computer, it stores them on computers in their data centers
You don't lose your Slack messages if you drop your computer in a lake, those messages exist on Slack's servers
How Does Web Communication Work?
When two computers communicate with each other, they need to use the same rules. An English speaker can't communicate verbally with a Japanese speaker, similarly, two computers need to speak the same language to communicate.

This "language" that computers use is called a protocol. The most popular protocol for web communication is HTTP, which stands for Hypertext Transfer Protocol.

Jello
Throughout this course, we'll be building parts of an online issue tracking app called "Jello". It's a typical issue tracker with one key difference: this time it's good, actually.

Assignment
Take a look at the getIssueData function that I've provided in http.go. It retrieves information about issues from Jello's servers via HTTP as a slice of bytes []byte.

In main.go do the following:

Convert the slice of bytes to a string with the built-in string() type conversion.
Print the string representation of the bytes to the console.
It should look like a long, unformatted string of text representing raw issue data.

Tip
Notice how none of the data that is logged to the console was generated within our code! That's because the data we retrieved is being sent over the internet from our servers via HTTP.




LESSON 2:
HTTP Requests and Responses
At the heart of HTTP is a simple request-response system. The "requesting" computer, also known as the "client", asks another computer for some information. That computer, "the server" sends back a response with the information that was requested.



We'll talk about the specifics of how the "requests" and "responses" are formatted later. For now, just think of it as a simple question-and-answer system.

Request: "What issues are on Jello?"
Response: ["Fix bug", "Improve auth flow"]






LESSON 3:
HTTP Powers Websites
HTTP, or Hypertext Transfer Protocol, is a protocol designed to transfer information between computers.

There are other protocols for communicating over the internet, but HTTP is the most popular and is particularly great for websites and web applications. Each time you visit a website, your browser is making an HTTP request to that website's server. The server responds with all the text, images, and styling information that your browser needs to render its pretty website!






LESSON 4 :
HTTP URLs
A URL, or Uniform Resource Locator, is the address of another computer, or "server" on the internet. Part of the URL specifies where to reach the server, and part of it tells the server what information we want.



Put simply, a URL represents a piece of information on some computer somewhere. We can get access to it by making a request, and reading the response that the server replies with.

Assignment
I've updated the getIssueData() function to be a bit more flexible. It now takes a URL as a parameter.

Try running the code in its current state. You should notice an error because the URL we're using is invalid.
Fix the code so that the call to getIssueData function uses the provided issueURL.
This time the printed data won't be as ugly, I added a prettify function that adds some formatting.





LESSON 5:
Using URLs in HTTP
The http:// at the beginning of a website URL specifies that the http protocol will be used for communication.



Other communication protocols use URLs as well, (hence "Uniform Resource Locator"). That's why we need to be specific when we're making HTTP requests by prefixing the URL with http://





LESSON 6:
Requests and Responses Quiz


A "client" is a computer making an HTTP request (whether it's a phone, a laptop, a desktop etc.)
A "server" is a computer responding to an HTTP request
A computer can be a client, a server, both, or neither. "Client" and "server" are just words we use to describe what computers are doing within a communication system.
Clients send requests and receive responses
Servers receive requests and send responses
Example Code
package main

import (
	"fmt"
	"io"
	"log"
	"net/http"
)

const usersUrl = "https://api.boot.dev/v1/courses_rest_api/learn-http/users"

func main() {
	users, err := getUserData(usersUrl)
	if err != nil {
		log.Fatalf("error getting user data: %v", err)
	}
	fmt.Println(string(users))
}

func getUserData(url string) ([]byte, error) {
	res, err := http.Get(url)
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer res.Body.Close()

	data, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response: %w", err)
	}

	return data, nil
}	







LESSON 8:
net/http
In this course, we'll be using Go's standard net/http package and the http.Client to make HTTP requests. In fact, we've already been using it! The http.Get function uses the http.DefaultClient under the hood.

Making a Request
import (
	"fmt"
	"io"
	"net/http"
)

func getProjects() ([]byte, error) {
	res, err := http.Get("https://api.jello.com/projects")
	if err != nil {
		return nil, fmt.Errorf("error making request: %w", err)
	}
	defer res.Body.Close()

	data, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, fmt.Errorf("error reading response: %w", err)
	}
	return data, nil
}

We'll go in-depth on the various things happening here later, but let's cover some basics for now.

http.Get uses the http.DefaultClient to make a request to the given url
res is the HTTP response that comes back from the server
defer res.Body.Close() ensures that the response body is properly closed after reading. Not doing so can cause memory issues.
io.ReadAll reads the response body into a slice of bytes []byte called data
Assignment
There is a bug in the getIssueData function! It's returning the entire http.Response instead of the data from the body (a slice of bytes). Fix it so that it returns []byte.

Use io.ReadAll to read the .Body of the response.
Return the resulting []byte








LESSON 9:
Web Clients
Click to hide video

As we've discussed, a web client is a device making requests to a web server.

A client can be any type of device but is often something users physically interact with. For example:

A desktop computer
A mobile phone
A tablet
In a website or web application, we call the user's device the "front-end".

A front-end client makes requests to a back-end server.









